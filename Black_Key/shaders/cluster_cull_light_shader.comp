#version 450 core

layout(local_size_x = 16, local_size_y = 9, local_size_z = 4) in;
#extension GL_GOOGLE_include_directive : require
#include "lights.glsl"
#include "cluster_info.glsl"

shared PointLight sharedLights[16 * 9 * 4];

#define MAX_LIGHTS_PER_CLUSTER 100

layout(push_constant) uniform Constants
{
	mat4 viewMatrix;
    uint numOfLights;
};

layout (set = 0, binding = 2) readonly buffer lightSSBO{
    PointLight pointLight[];
};

layout (set = 0, binding = 3) buffer lightIndexSSBO{
    uint globalLightIndexList[];
};

layout (set = 0, binding = 4) buffer lightGridSSBO{
    LightGrid lightGrid[];
};

layout (set = 0, binding = 5) buffer globalIndexCountSSBO{
    uint globalIndexCount;
};

float SquaredDistancePointAABB(vec3 point, uint tile)
{
	VolumeTileAABB currentCell = cluster[tile];

	float sqDist = 0.0;
	for (uint i = 0; i < 3; ++i)
	{
		float v = point[i];
		if (v < currentCell.minPoint[i])
		{
			float diff = currentCell.minPoint[i] - v;
			sqDist += (diff * diff);
		}
		else if (v > currentCell.maxPoint[i])
		{
			float diff = currentCell.maxPoint[i] - v;
			sqDist += (diff * diff);
		}
	}

	return sqDist;
}

bool TestSphereAABB(uint lightIndex, uint tile)
{
	float lightRadius = pointLight[lightIndex].range;
	vec4 posWorld = pointLight[lightIndex].position;
	vec4 posView = viewMatrix * posWorld;
	float squaredDistance = SquaredDistancePointAABB(posView.xyz, tile);

	return squaredDistance < (lightRadius * lightRadius);
}

void main()
{
    /*
	globalIndexCount = 0;
    uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
    uint lightCount  = pointLight.length();
    uint numBatches = (lightCount + threadCount -1) / threadCount;

    uint tileIndex = gl_LocalInvocationIndex + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * gl_WorkGroupID.z;
    
    uint visibleLightCount = 0;
    uint visibleLightIndices[100];

    for( uint batch = 0; batch < numBatches; ++batch){
        uint lightIndex = batch * threadCount + gl_LocalInvocationIndex;

        //Prevent overflow by clamping to last light which is always null
        lightIndex = min(lightIndex, lightCount);

        //Populating shared light array
        sharedLights[gl_LocalInvocationIndex] = pointLight[lightIndex];
        barrier();

        //Iterating within the current batch of lights
        for( uint light = 0; light < threadCount; ++light){
            if( sharedLights[light].enabled  == 1){
                if( testSphereAABB(light, tileIndex) ){
                    visibleLightIndices[visibleLightCount] = batch * threadCount + light;
                    visibleLightCount += 1;
                }
            }
        }
    }

    //We want all thread groups to have completed the light tests before continuing
    barrier();

    uint offset = atomicAdd(globalIndexCount, visibleLightCount);

    for(uint i = 0; i < visibleLightCount; ++i){
        globalLightIndexList[offset + i] = visibleLightIndices[i];
    }

    lightGrid[tileIndex].offset = offset;
    lightGrid[tileIndex].count = visibleLightCount;
    */

    uint tileIndex = gl_WorkGroupID.x +
		gl_WorkGroupID.y * gl_NumWorkGroups.x +
		gl_WorkGroupID.z * gl_NumWorkGroups.x * gl_NumWorkGroups.y;

    uint visibleLightIndices[MAX_LIGHTS_PER_CLUSTER];

	uint numAllLights = numOfLights;

    uint lightIter = 0;
	for (uint i = 0; i < numAllLights && lightIter < MAX_LIGHTS_PER_CLUSTER; ++i)
	{
		if (TestSphereAABB(i, tileIndex))
		{
			visibleLightIndices[lightIter++] = i;
		}
	}
	uint offset = atomicAdd(globalIndexCount, lightIter);

	for (uint i = 0; i < lightIter; ++i)
	{
		globalLightIndexList[offset + i] = visibleLightIndices[i];
	}

    float free_love = 6.7;
	lightGrid[tileIndex].offset = offset;
	lightGrid[tileIndex].count  = lightIter;
}

float sqDistPointAABB(vec3 point, uint tile){
    float sqDist = 0.0;
    VolumeTileAABB currentCell = cluster[tile];
    cluster[tile].maxPoint[3] = tile;
    for(int i = 0; i < 3; ++i){
        float v = point[i];
        if(v < currentCell.minPoint[i]){
            sqDist += (currentCell.minPoint[i] - v) * (currentCell.minPoint[i] - v);
        }
        if(v > currentCell.maxPoint[i]){
            sqDist += (v - currentCell.maxPoint[i]) * (v - currentCell.maxPoint[i]);
        }
    }

    return sqDist;
}